/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <unistd.h>
#include <string>

#include <android-base/file.h>
#include <android-base/test_utils.h>
#include <gtest/gtest.h>

#include "JavaGen.h"

namespace {

constexpr const char* kTestSyspropFile =
    R"(owner: Vendor
module: "com.somecompany.TestProperties"
prefix: "com.somecompany"

prop {
    name: "test_double"
    type: Double
    scope: Internal
}
prop {
    name: "test_int"
    type: Integer
    scope: Public
}
prop {
    name: "test.string"
    type: String
    scope: System
    readonly: true
}

prop {
    name: "test.enum"
    type: Enum
    enum_values: "a|b|c|D|e|f|G"
    scope: Internal
    readonly: false
}
prop {
    name: "test_BOOLeaN"
    type: Boolean
    scope: Public
}
prop {
    name: "longlonglongLONGLONGlongLONGlongLONG"
    type: Long
    scope: System
}

prop {
    name: "test_double_list"
    type: DoubleList
    scope: Internal
}
prop {
    name: "test_list_int"
    type: IntegerList
    scope: Public
}
prop {
    name: "test.strlist"
    type: StringList
    scope: System
    readonly: false
}

prop {
    name: "el"
    type: EnumList
    enum_values: "enu|mva|lue"
    scope: Internal
}
)";

constexpr const char* kExpectedJavaOutput =
    R"(// Generated by the sysprop generator. DO NOT EDIT!

package com.somecompany;

import android.annotation.SystemApi;

import java.util.ArrayList;
import java.util.function.Function;
import java.util.List;
import java.util.Optional;
import java.util.StringJoiner;

public final class TestProperties {
    private TestProperties () {}

    static {
        System.loadLibrary("TestProperties_jni");
    }

    private static Boolean tryParseBoolean(String str) {
        switch (str.toLowerCase()) {
            case "1":
            case "y":
            case "yes":
            case "on":
            case "true":
                return Boolean.TRUE;
            case "0":
            case "n":
            case "no":
            case "off":
            case "false":
                return Boolean.FALSE;
            default:
                return null;
        }
    }

    private static Integer tryParseInteger(String str) {
        try {
            return Integer.valueOf(str);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static Long tryParseLong(String str) {
        try {
            return Long.valueOf(str);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static Double tryParseDouble(String str) {
        try {
            return Double.valueOf(str);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static String tryParseString(String str) {
        return str;
    }

    private static <T extends Enum<T>> T tryParseEnum(Class<T> enumType, String str) {
        try {
            return Enum.valueOf(enumType, str);
        } catch (IllegalArgumentException e) {
            return null;
        }
    }

    private static <T> List<T> tryParseList(Function<String, T> elementParser, String str) {
        List<T> ret = new ArrayList<>();

        for (String element : str.split(",")) {
            T parsed = elementParser.apply(element);
            if (parsed == null) {
                return null;
            }
            ret.add(parsed);
        }

        return ret;
    }

    private static <T extends Enum<T>> List<T> tryParseEnumList(Class<T> enumType, String str) {
        List<T> ret = new ArrayList<>();

        for (String element : str.split(",")) {
            T parsed = tryParseEnum(enumType, element);
            if (parsed == null) {
                return null;
            }
            ret.add(parsed);
        }

        return ret;
    }

    private static <T> String formatList(List<T> list) {
        StringJoiner joiner = new StringJoiner(",");

        for (T element : list) {
            joiner.add(element.toString());
        }

        return joiner.toString();
    }

    /** @hide */
    public static Optional<Double> test_double() {
        return Optional.ofNullable(tryParseDouble(native_test_double_get()));
    }

    private static native String native_test_double_get();

    public static Optional<Integer> test_int() {
        return Optional.ofNullable(tryParseInteger(native_test_int_get()));
    }

    private static native String native_test_int_get();

    @SystemApi
    public static Optional<String> test_string() {
        return Optional.ofNullable(tryParseString(native_test_string_get()));
    }

    private static native String native_test_string_get();

    /** @hide */
    public static enum test_enum_values {
        a,
        b,
        c,
        D,
        e,
        f,
        G,
    }

    /** @hide */
    public static Optional<test_enum_values> test_enum() {
        return Optional.ofNullable(tryParseEnum(test_enum_values.class, native_test_enum_get()));
    }

    private static native String native_test_enum_get();

    /** @hide */
    public static boolean test_enum(test_enum_values value) {
        return native_test_enum_set(value.toString());
    }

    private static native boolean native_test_enum_set(String str);

    public static Optional<Boolean> test_BOOLeaN() {
        return Optional.ofNullable(tryParseBoolean(native_test_BOOLeaN_get()));
    }

    private static native String native_test_BOOLeaN_get();

    @SystemApi
    public static Optional<Long> longlonglongLONGLONGlongLONGlongLONG() {
        return Optional.ofNullable(tryParseLong(native_longlonglongLONGLONGlongLONGlongLONG_get()));
    }

    private static native String native_longlonglongLONGLONGlongLONGlongLONG_get();

    /** @hide */
    public static Optional<List<Double>> test_double_list() {
        return Optional.ofNullable(tryParseList(v -> tryParseDouble(v), native_test_double_list_get()));
    }

    private static native String native_test_double_list_get();

    public static Optional<List<Integer>> test_list_int() {
        return Optional.ofNullable(tryParseList(v -> tryParseInteger(v), native_test_list_int_get()));
    }

    private static native String native_test_list_int_get();

    @SystemApi
    public static Optional<List<String>> test_strlist() {
        return Optional.ofNullable(tryParseList(v -> tryParseString(v), native_test_strlist_get()));
    }

    private static native String native_test_strlist_get();

    @SystemApi
    public static boolean test_strlist(List<String> value) {
        return native_test_strlist_set(formatList(value));
    }

    private static native boolean native_test_strlist_set(String str);

    /** @hide */
    public static enum el_values {
        enu,
        mva,
        lue,
    }

    /** @hide */
    public static Optional<List<el_values>> el() {
        return Optional.ofNullable(tryParseEnumList(el_values.class, native_el_get()));
    }

    private static native String native_el_get();
}
)";

constexpr const char* kExpectedJniOutput =
    R"(// Generated by the sysprop generator. DO NOT EDIT!

#define LOG_TAG "com.somecompany.TestProperties_jni"

#include <cstdint>
#include <iterator>
#include <string>

#include <dlfcn.h>
#include <jni.h>

#include <android-base/logging.h>

namespace {

constexpr const char* kClassName = "com/somecompany/TestProperties";

namespace libc {

struct prop_info;

const prop_info* (*system_property_find)(const char* name);

void (*system_property_read_callback)(
    const prop_info* pi,
    void (*callback)(void* cookie, const char* name, const char* value, std::uint32_t serial),
    void* cookie
);

int (*system_property_set)(const char* key, const char* value);

void* handle;

__attribute__((constructor)) void load_libc_functions() {
    handle = dlopen("libc.so", RTLD_LAZY | RTLD_NOLOAD);

    system_property_find = reinterpret_cast<decltype(system_property_find)>(dlsym(handle, "__system_property_find"));
    system_property_read_callback = reinterpret_cast<decltype(system_property_read_callback)>(dlsym(handle, "__system_property_read_callback"));
    system_property_set = reinterpret_cast<decltype(system_property_set)>(dlsym(handle, "__system_property_set"));
}

__attribute__((destructor)) void release_libc_functions() {
    dlclose(handle);
}

jstring GetProp(JNIEnv* env, const char* key) {
    auto pi = system_property_find(key);
    if (pi == nullptr) return env->NewStringUTF("");
    std::string ret;
    system_property_read_callback(pi, [](void* cookie, const char*, const char* value, std::uint32_t) {
        *static_cast<std::string*>(cookie) = value;
    }, &ret);
    return env->NewStringUTF(ret.c_str());
}

}  // namespace libc

class ScopedUtfChars {
  public:
    ScopedUtfChars(JNIEnv* env, jstring s) : env_(env), string_(s) {
        utf_chars_ = env->GetStringUTFChars(s, nullptr);
    }

    ~ScopedUtfChars() {
        if (utf_chars_) {
            env_->ReleaseStringUTFChars(string_, utf_chars_);
        }
    }

    const char* c_str() const {
        return utf_chars_;
    }

  private:
    JNIEnv* env_;
    jstring string_;
    const char* utf_chars_;
};

jstring JNICALL test_double_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.test_double");
}

jstring JNICALL test_int_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.test_int");
}

jstring JNICALL test_string_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.test.string");
}

jstring JNICALL test_enum_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "com.somecompany.test.enum");
}

jboolean JNICALL test_enum_set(JNIEnv* env, jclass, jstring str) {
    return libc::system_property_set("com.somecompany.test.enum", ScopedUtfChars(env, str).c_str()) == 0 ? JNI_TRUE : JNI_FALSE;
}

jstring JNICALL test_BOOLeaN_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.test_BOOLeaN");
}

jstring JNICALL longlonglongLONGLONGlongLONGlongLONG_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.longlonglongLONGLONGlongLONGlongLONG");
}

jstring JNICALL test_double_list_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.test_double_list");
}

jstring JNICALL test_list_int_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.test_list_int");
}

jstring JNICALL test_strlist_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "com.somecompany.test.strlist");
}

jboolean JNICALL test_strlist_set(JNIEnv* env, jclass, jstring str) {
    return libc::system_property_set("com.somecompany.test.strlist", ScopedUtfChars(env, str).c_str()) == 0 ? JNI_TRUE : JNI_FALSE;
}

jstring JNICALL el_get(JNIEnv* env, jclass) {
    return libc::GetProp(env, "ro.com.somecompany.el");
}

const JNINativeMethod methods[] = {
    {"native_test_double_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_double_get)},
    {"native_test_int_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_int_get)},
    {"native_test_string_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_string_get)},
    {"native_test_enum_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_enum_get)},
    {"native_test_enum_set", "(Ljava/lang/String;)Z", reinterpret_cast<void*>(test_enum_set)},
    {"native_test_BOOLeaN_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_BOOLeaN_get)},
    {"native_longlonglongLONGLONGlongLONGlongLONG_get", "()Ljava/lang/String;", reinterpret_cast<void*>(longlonglongLONGLONGlongLONGlongLONG_get)},
    {"native_test_double_list_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_double_list_get)},
    {"native_test_list_int_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_list_int_get)},
    {"native_test_strlist_get", "()Ljava/lang/String;", reinterpret_cast<void*>(test_strlist_get)},
    {"native_test_strlist_set", "(Ljava/lang/String;)Z", reinterpret_cast<void*>(test_strlist_set)},
    {"native_el_get", "()Ljava/lang/String;", reinterpret_cast<void*>(el_get)},
};

}  // namespace

jint JNI_OnLoad(JavaVM* vm, void*) {
    JNIEnv* env = nullptr;

    if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
        LOG(ERROR) << "GetEnv failed";
        return -1;
    }

    jclass clazz = env->FindClass(kClassName);
    if (clazz == nullptr) {
        LOG(ERROR) << "Cannot find class " << kClassName;
        return -1;
    }

    if (env->RegisterNatives(clazz, methods, std::size(methods)) < 0) {
        LOG(ERROR) << "RegisterNatives failed";
        return -1;
    }

    return JNI_VERSION_1_6;
}
)";

}  // namespace

using namespace std::string_literals;

TEST(SyspropTest, JavaGenTest) {
  TemporaryFile temp_file;

  // strlen is optimized for constants, so don't worry about it.
  ASSERT_EQ(write(temp_file.fd, kTestSyspropFile, strlen(kTestSyspropFile)),
            strlen(kTestSyspropFile));
  close(temp_file.fd);
  temp_file.fd = -1;

  TemporaryDir temp_dir;

  std::string err;
  ASSERT_TRUE(
      GenerateJavaLibrary(temp_file.path, temp_dir.path, temp_dir.path, &err));
  ASSERT_TRUE(err.empty());

  std::string java_output_path =
      temp_dir.path + "/com/somecompany/TestProperties.java"s;
  std::string jni_output_path = temp_dir.path + "/TestProperties_jni.cpp"s;

  std::string java_output;
  ASSERT_TRUE(
      android::base::ReadFileToString(java_output_path, &java_output, true));
  ASSERT_EQ(java_output, kExpectedJavaOutput);

  std::string jni_output;
  ASSERT_TRUE(
      android::base::ReadFileToString(jni_output_path, &jni_output, true));
  ASSERT_EQ(jni_output, kExpectedJniOutput);

  unlink(java_output_path.c_str());
  rmdir((temp_dir.path + "/com/somecompany"s).c_str());
  rmdir((temp_dir.path + "/com"s).c_str());
  unlink(jni_output_path.c_str());
}
